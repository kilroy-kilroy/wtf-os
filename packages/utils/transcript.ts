/**
 * Transcript processing utilities
 */

export interface TranscriptSegment {
  speaker: string;
  text: string;
  timestamp?: string;
}

/**
 * Normalize transcript from various formats
 * Supports common formats from Zoom, Fireflies, Gong, etc.
 */
export function normalizeTranscript(rawTranscript: string): string {
  let normalized = rawTranscript.trim();

  // Remove common headers/footers
  normalized = normalized.replace(/^Transcript\s*$/im, '');
  normalized = normalized.replace(/^Generated by.*$/im, '');
  normalized = normalized.replace(/^Recorded on.*$/im, '');

  // Normalize timestamps
  // Format: [00:12:34] or (00:12:34) or 00:12:34:
  normalized = normalized.replace(/[\[\(](\d{1,2}:\d{2}:\d{2})[\]\)]/g, '$1:');

  // Clean up excessive whitespace
  normalized = normalized.replace(/\n\n\n+/g, '\n\n');
  normalized = normalized.replace(/[ \t]+/g, ' ');

  return normalized.trim();
}

/**
 * Parse transcript into segments
 */
export function parseTranscript(transcript: string): TranscriptSegment[] {
  const segments: TranscriptSegment[] = [];
  const lines = transcript.split('\n');

  let currentSpeaker = '';
  let currentText = '';
  let currentTimestamp = '';

  for (const line of lines) {
    // Check for speaker line (format: "Name:" or "Name [timestamp]:")
    const speakerMatch = line.match(/^([^:]+?)(\s*\[?\d{1,2}:\d{2}(?::\d{2})?\]?)?:\s*(.*)$/);

    if (speakerMatch) {
      // Save previous segment if exists
      if (currentSpeaker && currentText) {
        segments.push({
          speaker: currentSpeaker.trim(),
          text: currentText.trim(),
          timestamp: currentTimestamp || undefined,
        });
      }

      // Start new segment
      currentSpeaker = speakerMatch[1].trim();
      currentTimestamp = speakerMatch[2]?.replace(/[\[\]]/g, '').trim() || '';
      currentText = speakerMatch[3];
    } else if (line.trim()) {
      // Continue current segment
      currentText += ' ' + line.trim();
    }
  }

  // Save last segment
  if (currentSpeaker && currentText) {
    segments.push({
      speaker: currentSpeaker.trim(),
      text: currentText.trim(),
      timestamp: currentTimestamp || undefined,
    });
  }

  return segments;
}

/**
 * Identify participants from transcript
 */
export function identifyParticipants(transcript: string): string[] {
  const segments = parseTranscript(transcript);
  const speakers = new Set<string>();

  for (const segment of segments) {
    speakers.add(segment.speaker);
  }

  return Array.from(speakers);
}

/**
 * Calculate transcript statistics
 */
export function getTranscriptStats(transcript: string): {
  wordCount: number;
  characterCount: number;
  estimatedDuration: number; // in seconds
  participantCount: number;
} {
  const wordCount = transcript.split(/\s+/).length;
  const characterCount = transcript.length;
  const participantCount = identifyParticipants(transcript).length;

  // Average speaking rate is ~150 words per minute
  const estimatedDuration = Math.round((wordCount / 150) * 60);

  return {
    wordCount,
    characterCount,
    estimatedDuration,
    participantCount,
  };
}

/**
 * Calculate talk/listen ratio
 * Returns percentage for each speaker
 */
export function calculateTalkListenRatio(
  transcript: string,
  repName: string
): { rep: number; prospect: number; other: number } {
  const segments = parseTranscript(transcript);
  let repWords = 0;
  let prospectWords = 0;
  let otherWords = 0;

  for (const segment of segments) {
    const wordCount = segment.text.split(/\s+/).length;

    if (segment.speaker.toLowerCase().includes(repName.toLowerCase())) {
      repWords += wordCount;
    } else if (
      segment.speaker.toLowerCase().includes('prospect') ||
      segment.speaker.toLowerCase().includes('client') ||
      segment.speaker.toLowerCase().includes('customer')
    ) {
      prospectWords += wordCount;
    } else {
      otherWords += wordCount;
    }
  }

  const totalWords = repWords + prospectWords + otherWords;
  if (totalWords === 0) {
    return { rep: 0, prospect: 0, other: 0 };
  }

  return {
    rep: Math.round((repWords / totalWords) * 100),
    prospect: Math.round((prospectWords / totalWords) * 100),
    other: Math.round((otherWords / totalWords) * 100),
  };
}

/**
 * Extract a snippet from transcript around a quote
 * Useful for providing context
 */
export function extractSnippet(
  transcript: string,
  quote: string,
  contextWords: number = 50
): string | null {
  const index = transcript.toLowerCase().indexOf(quote.toLowerCase());
  if (index === -1) return null;

  // Find start and end positions with context
  const words = transcript.split(/\s+/);
  let currentPos = 0;
  let startIndex = 0;
  let endIndex = words.length;

  for (let i = 0; i < words.length; i++) {
    const wordEnd = currentPos + words[i].length;

    if (currentPos <= index && wordEnd >= index) {
      startIndex = Math.max(0, i - contextWords);
      endIndex = Math.min(words.length, i + contextWords);
      break;
    }

    currentPos = wordEnd + 1; // +1 for space
  }

  const snippet = words.slice(startIndex, endIndex).join(' ');
  return (startIndex > 0 ? '...' : '') + snippet + (endIndex < words.length ? '...' : '');
}
